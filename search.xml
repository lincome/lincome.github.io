<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>活着(余华)</title>
    <url>/2017/03/14/2017-3-14-to-live/</url>
    <content><![CDATA[<p>「人是为了活着本身而活着，而不是为了活着之外的任何事物而活着」–余华</p>
<h3 id="gitbook地址"><a href="#gitbook地址" class="headerlink" title="gitbook地址"></a><a href="https://lincome.gitbooks.io/to-live/content/">gitbook地址</a></h3>]]></content>
      <categories>
        <category>文学</category>
      </categories>
  </entry>
  <entry>
    <title>顺风车</title>
    <url>/2017/03/15/2017-3-15-sfc/</url>
    <content><![CDATA[<h4 id="关于本项目"><a href="#关于本项目" class="headerlink" title="关于本项目"></a>关于本项目</h4><p>　　练手项目，高手轻喷。</p>
<h4 id="github"><a href="#github" class="headerlink" title="github"></a><a href="https://github.com/lincome/sfc">github</a></h4>]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>水调歌头</title>
    <url>/2017/03/17/2017-3-17-sdgt/</url>
    <content><![CDATA[<h2 id="水调歌头"><a href="#水调歌头" class="headerlink" title="水调歌头"></a>水调歌头</h2><blockquote>
<p>苏轼</p>
</blockquote>
<p> 明月几时有 把酒问青天  </p>
<p> 不知天上宫阙 今夕是何年  </p>
<p> 我欲乘风归去 惟恐琼楼玉宇 高处不胜寒  </p>
<p> 起舞弄清影 何似在人间  </p>
<p> 转朱阁 低绮户 照无眠  </p>
<p> 不应有恨 何事长向别时圆  </p>
<p> 人有悲欢离合 月有阴晴圆缺 此事古难全  </p>
<p> 但愿人长久 千里共婵娟</p>
<hr>
<p> 一时有感而发，无论面对什么样的结局，即使事事皆不尽人意，都不应有恨,月有阴晴圆缺，从古至今都无法圆满结局，又何需悲伤呢，向苏东坡先生学习豁达的胸襟。收拾心情，继续出发!尽力而为!</p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
  </entry>
  <entry>
    <title>射雕英雄传</title>
    <url>/2017/03/18/2017-3-18-sdyxz/</url>
    <content><![CDATA[<h2 id="射雕英雄传"><a href="#射雕英雄传" class="headerlink" title="射雕英雄传"></a>射雕英雄传</h2><p>　　又追完一部金庸武侠剧了，从小看到大的剧，每次看都不一样的感觉，小时候懵懂，<br>只觉得画面优美，风景秀丽，现在看来更美，也更能看清楚郭靖跟黄蓉的爱情，<br>“活，你背着我，死，你也背着我”。</p>
<h2 id="剧照欣赏"><a href="#剧照欣赏" class="headerlink" title="剧照欣赏"></a>剧照欣赏</h2><p>女神镇楼<br><img  src="/images/sdyxz/421fa8d3fd1f41341d930e8d2c1f95cad0c85e9a.jpg"  ><span class="image-caption">张一桐</span></p>
<p><img  src="/images/sdyxz/de86e950352ac65c23771280f2f2b21192138ad0.jpg"  ><span class="image-caption">张一桐</span></p>
<p><img  src="/images/sdyxz/6e83b9014a90f603932e90b43012b31bb151edad.jpg"  ><span class="image-caption">张一桐</span></p>
<p><img  src="/images/sdyxz/48.jpg"  ><span class="image-caption">郭靖</span></p>
<p><img  src="/images/sdyxz/47.jpg"  ><span class="image-caption">杨康</span></p>
<p><img  src="/images/sdyxz/46.jpg"  ><span class="image-caption">穆念慈</span></p>
<p><img  src="/images/sdyxz/351273f082025aaf61b87438f2edab64024f1ab8.jpg"  ><span class="image-caption">黄药师</span></p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title>孙子兵法-始计篇</title>
    <url>/2017/03/20/2017-3-20-szbf/</url>
    <content><![CDATA[<p>　　孙子曰：兵者，国之大事，死生之地，存亡之道，不可不察。  </p>
<blockquote>
<p>盈利，公司的大事，死生之地，存亡之道，不可不察。</p>
</blockquote>
<p>　　故经之以五事，校之以计而索其情：一曰道，二曰天，三曰地，四曰将，五曰法。道者，令民与上同意也，故可以与之死，可以与之生，而不畏危。天者，阴阳、寒暑、时制也。地者，远近、险易、广狭、死生也。将者，智、信、仁、勇、严也。法者，曲制、官道、主用也。凡此五者，将莫不闻、知之者胜，不知者不胜。故校之以计而索其情，曰：主孰有道？将孰有能？天地孰得？法令孰行？兵众孰强？士卒孰练？赏罚孰明？吾以此知胜负矣。</p>
<blockquote>
<p>成功公司的5个要点：道，天，地，将，法，道：员工与公司的意愿一致，则员工必会卖命为公司做事，不计较加班，多做少做，毫无怨言；天：把握时代潮流，趋势，遵循当下社会背景，不背离时代趋势；地：制定下可实施落地方案策略，不能天马行空，而要实事求是；将：领导者的素质，智、信、仁、勇、严；法：公司规章制度，赏罚分明，晋升制度必须明确。</p>
</blockquote>
<p>　　将听吾计，用之必胜，留之；将不听吾计，用之必败，去之。</p>
<blockquote>
<p>领导若听从我的意见，经营公司必定成功，我就留下来。反之，离去。</p>
</blockquote>
<p>　　计利以听，乃为之例，以佐其外。 势者，因利而制权也。兵者，诡道也。故能而示之不能，用而示之不用，近而示之远，远而示之近；利而诱之，乱而取之，实而备之，强而避之，怒而挠之，卑而骄之，佚而劳之，亲而离之。攻其不备，出其不意。此兵家之胜，不可先传也。</p>
<blockquote>
<p>领导者要顺势而为，随机应变，迷惑对方，利用对手弱点，攻其不备，出其不意，，，领导者知道这些秘诀但在结果未知之前不可以讲出来</p>
</blockquote>
<p>　　夫未战而庙算胜者，得算多也；未战而庙算不胜者，得算少也；多算胜，少算不胜，而况于无算乎！吾以此观之，胜负见矣。</p>
<blockquote>
<p>运筹帷幄之中，决胜千里之外，成功总是属于有准备的人，做事前三思而后行，没有经过思考草率行事必定失败！</p>
</blockquote>
<hr>
<h1 id="gitbook"><a href="#gitbook" class="headerlink" title="gitbook"></a><a href="https://lincome.gitbooks.io/szbf/content/">gitbook</a></h1>]]></content>
      <categories>
        <category>文学</category>
      </categories>
  </entry>
  <entry>
    <title>看不见的客人</title>
    <url>/2017/03/26/2017-3-26-kbjdkr/</url>
    <content><![CDATA[<p>　　高智商电影，值得一看，刺激下平凡的生活，锻炼脑力，好处多多！看这样的电影就是一场享受，不浪费一分钟，没有多余一个镜头，酣畅淋漓，一气呵成，痛苦，看完之后佩服男主的智商同时更认清了，天网恢恢疏而不漏，人性必须不断反思，方能避免留下一生的阴影，不过像我这种智商基本上没有作恶的可能了！</p>
<hr>
<p>　　艾德里安（马里奥·卡萨斯 Mario Casas 饰）经营着一间科技公司，事业蒸蒸日上，家中有美丽贤惠的妻子和活泼可爱的女儿，事业家庭双丰收的他是旁人羡慕的对象。然而，野心勃勃的艾德里安并未珍惜眼前来之不易的生活，一直以来，他和一位名叫劳拉（芭芭拉·蓝妮 Bárbara Lennie 饰）的女摄影师保持着肉体关系。</p>
<p>　　某日幽会过后，两人驱车离开别墅，却在路上发生了车祸，为了掩盖事件的真相，两人决定将在车祸中死去的青年丹尼尔联同他的车一起沉入湖底。之后，劳拉遇见了一位善良的老人，老人将劳拉坏掉的车拉回家中修理，然而，令劳拉没有想到的是，这位老人，竟然就是丹尼尔的父亲。　　</p>
<p><img  src="/images/kbjdkr/140515.74695469.jpg"  ><span class="image-caption">1</span></p>
<p>　　当一次事件成了几人各执一词的「罗生门」，就是人性有待大考的时刻了。事实真相在“真相”与“假象”之中徘徊：渣男按照对自己有利的方式进行表述，精心编织着他的谎言，而缺乏有力的证据致使这个事实真相扑朔迷离，难以水落石出。</p>
<p>　　人性的自私一点点催生着阴暗面直到吞噬自己。他道貌岸然的伪装起一个被迫受唆使做了一生中最坏的事的良好商人形象，在这个有不败纪录的律师面前表现的不知所措，坚称自己是无辜的。我们都有自私的一面，在陈述一个事实的时候，如果这事情没那么光彩，我们的潜意识里会刻意美化它，就如同照镜子，自己眼中的自己比起照片里的就要顺眼很多，那是大脑的条件反射，视网膜成像后所看到的是被美化了的自己。</p>
<p><img  src="/images/kbjdkr/140533.66947597.jpg"  ><span class="image-caption">1</span></p>
<p>　　他一开始用了错误的方式方法去掩盖事实真相，结果事情却像蝴蝶效应一样越演越烈，最后变成了一场谋杀和一场灭口案件。现在死无对证，全凭他一言之词，但在律师强势的逼问之下，他也慌了阵脚。这个反转又反转的罗生门，最后终于拼凑起所有的真相。</p>
<p><img  src="/images/kbjdkr/140558.63361577.jpg"  ><span class="image-caption">1</span></p>
<p>　　总体来说这部西班牙悬疑片剧情流畅，张力十足，用套路反套路，最后受害者父母和渣男见招拆招的对决真是痛快。所以，还是痛快点，撕破脸皮坦诚相见才不会让自己一步步作死。他摘下伪装的面具后发现律师也撕下了伪装，两栋建筑物遥相对峙让戏剧冲突达到高潮。没有痛苦，就没有拯救，人啊，不要自以为是以为只有自己最聪明。人性的阴暗面可以让人淡定面对自己的污点，但事实真相无论如何扭曲都是不会动摇和改变的，他以为自己瞒过了所有人，实际上却输在了自负上。</p>
<p><img  src="/images/kbjdkr/140624.71872860.jpg"  ><span class="image-caption">1</span></p>
<p>　　在黑暗的人性下寻找难以触碰的真相这个主题其实很吸引人，可惜电影如果仔细观察小细节看到后半段基本就可以知道结局了。同类型的犯罪悬疑题材感觉《控方证人》（1957年版本）要更牛，不到最后一刻你根本不会了解真相。比利·怀尔德没有一个镜头是多余的，一气呵成将被告的虚伪的嘴脸揭露出来。当然，这两部电影其实并没可比性，《看不见的客人》预埋的伏笔太多太明显，导致少了很多观悬疑电影的刺激和乐趣。</p>
<p>原文地址：<a href="http://i.mtime.com/kiki204629/blog/8000024/">http://i.mtime.com/kiki204629/blog/8000024/</a></p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title>杰出公民</title>
    <url>/2017/04/15/2017-4-15-jcgm/</url>
    <content><![CDATA[<p>　　梦想完全被现实打败，看似幽默戏剧诙谐的电影，内心却是异常的沉重。获得若贝尔文学奖的主人公选择回去40年前自己的生活了20年的家乡，正如小说中所说的：人生中最正确的一次选择是逃离家乡，但离不开的是故乡，回不去的也是故乡。所有的成就皆是来源于故乡的素材，一举成名天下知后，来自老乡们从一开始的崇拜到后面的嫉妒羡慕，到乡下人独有的愚昧，“你让我觉得自己很差，所以你该死”，是否能回到故乡对他来说再无任何意义。</p>
<hr>
<p>　　剧照一张</p>
<p><img  src="/images/20160905104225232846.jpg"  ><span class="image-caption">1</span></p>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
  </entry>
  <entry>
    <title>docker让我们步入了工业时代</title>
    <url>/2017/04/18/2017-4-18-docker/</url>
    <content><![CDATA[<p>　　这么多年的it工作经历，每每开发之前都要搭建部署各种开发环境，jsp、C#、php、python、mysql等等等等开发环境，这些环境部署起来简直要人命，无论在windows下，还是linux下搭建，各种开发包，环境变量配置，关联文件下载，配置文件配置，折腾起来慢的得好几天时间，都会开始怀疑人生的，所以便把签名都改成：人生苦短，不要折腾！现如今才知道有docker这种神器，真是枉活20有6，docker在2013年就出来了，落后了很多年了，知识体系更新赶不上技术更新，真是惭愧，不经感叹：too young too simple！</p>
<hr>
<p>　　docker</p>
<p><img  src="/images/20161221173314498.png"  ><span class="image-caption">1</span></p>
<h2 id="集装箱的作用"><a href="#集装箱的作用" class="headerlink" title="集装箱的作用"></a>集装箱的作用</h2><p>　　我们可以想想在集装箱这个定义出来之前的货物运输：货物一箱箱的搬上货车送到附近的火车站，然后一箱箱卸下，再一箱箱的搬上火车运送到附近的码头…</p>
<p>　　上述的过程中不难发现大量的人力和时间成本都花费在一箱箱的搬运上面，在运输速度一定的情况下，装卸就成为了物流的瓶颈。</p>
<p>　　在集装箱出现后这个问题得到了极大的改善。集装箱重要在它提供了一种通用的封装货物的标准规格（尺寸，外形符合统一标准），这样就产生了一个巨大的优点：在物流运输中只需要在运输前一次封装，集装箱就可以放上火车，卡车，拉到码头，直接放在货船上；卸船之后直接再放上火车，卡车，运送到目的地。而且由于集装箱符合统一标准，整个流程非常容易机械化，这引发了以集装箱为中心的整个全球物流的标准化进程，从而节省了大量的时间资源和人力资源，成本迅速下降，促进了全球资源的流动与重新配置。</p>
<h2 id="Docker与集装箱"><a href="#Docker与集装箱" class="headerlink" title="Docker与集装箱"></a>Docker与集装箱</h2><p>　　docker就像码头的工人一样，把应用打包为一个个封装好的标准集装箱，就是大家口中经常镜像文件。那docker为业内带来了什么呢？</p>
<h2 id="docker诞生以前，运维的蛮荒时代"><a href="#docker诞生以前，运维的蛮荒时代" class="headerlink" title="docker诞生以前，运维的蛮荒时代"></a>docker诞生以前，运维的蛮荒时代</h2><p>　　以前我们搭建一个网站，你可能会装PHP,MySQL，Apache等等一堆软件，好花费大半天的时间这个网站能正常运行起来了。</p>
<p>　　一段时间后我们需要更高的PHP版本来搭建一个其他类型的网站，版本冲突了咋整？一番google后，费了九牛二虎之力两个网站终于能共同运行了。</p>
<p>　　老板后来告诉你由于网站太火爆了我们需要换一台服务器迁移过去，于是你又不得不巴拉巴拉的折腾一番将所有的环境重新配置一遍。</p>
<p>　　老板小手一拍，我们要优化我们的服务，在全国各地都建立节点提供服务，你掰一掰的你手指头发现有数不清的环境需要搭建，你的内心是崩溃的。</p>
<h2 id="docker出现后，我们步入了工业时代"><a href="#docker出现后，我们步入了工业时代" class="headerlink" title="docker出现后，我们步入了工业时代"></a>docker出现后，我们步入了工业时代</h2><p>　　就和 集装箱 一样，docker为我们带来的是标准，具体一点说就是镜像。在docker当中镜像其实就是你把一大包工具打包成一个集装箱交于docker运行，镜像与镜像之间互不影响(集装箱与集装箱之间也是互不影响运输)。</p>
<p>　　在docker中，镜像是无法直接运行的，我猜想这并不是技术上的原因，而是工程设计上的原因。因为一般来说，一个软件的某个具体版本只会打包成一个镜像。如果镜像可以配置，运行的话，在使用过程中很可能会对镜像造成破坏。</p>
<p>　　那怎么样避免这个问题呢，就是再加一层，也就是相当于用了分身术，只要本尊没问题，分身怎么扑街都不会真正的跪掉。多加的这一层分身，就叫容器（Container），这个名字也挺形象，它就像个盒子一样，你的应用在里面运行，而且多了一层安全机制。你想使用服务或把你的应用跑起来的话，只需要使用镜像新创建一个容器就可以了（也是一条命令搞定），而镜像还放在那里不动，没办法，金贵嘛。</p>
<h2 id="docker究竟做了什么？"><a href="#docker究竟做了什么？" class="headerlink" title="docker究竟做了什么？"></a>docker究竟做了什么？</h2><p>　　docker正是在部署过程中，将上面那些重复的部分，由docker自动化完成。只需要在第一次部署时，构建完可用的docker镜像。然后在以后使用的过程中，短短的几行命令，就可以直接拉取镜像，根据这个镜像创建出一个容器，把服务跑起来了。所需要的仅仅是安装了docker的服务器，一个Dockerfile文件，以及比较流畅的网络而已。真可谓 一次构建，到处部署 。</p>
<ul>
<li>需要nginx,直接pull nginx镜像完事</li>
<li>迁移服务器？直接下载一个非常小的Dockerfile，安装一- 个docker环境即可，简单的不能在简单</li>
<li>多个版本共存？新建一个镜像，爱用哪个版本用哪个，容器的隔离性让我们就是这么任性</li>
</ul>
<p>　　到这个地方，你可能已经发现了，docker镜像成为了一种像集装箱那样的标准货件。它不像传统的软件交付方式那样，只把代码以及说明文档之类的给你就完了，而是直接给你一个标准docker货件，它可能是Dockerfile，或者直接就是镜像，这个标准件不仅包括了代码本身，还包括了代码运行的OS等各种整体环境。</p>
<p>　　于是，谁想用我的服务，直接拉取镜像，实例化一个容器就可以了，能直接提供你所要的服务，不再像之前那样有繁复的安装过程————这些都有人给你做过了。</p>
<h2 id="与传统虚拟机对比"><a href="#与传统虚拟机对比" class="headerlink" title="与传统虚拟机对比"></a>与传统虚拟机对比</h2><p>　　有人可能会说，这些不是虚拟机都做到了么，还要docker干嘛？</p>
<p>　　传统虚拟机就像一个老爷爷，走路晃晃悠悠，还需要分配资源，给予照顾才行。反观docker则像是一个健步如飞的年轻小伙子，干啥事都是一个字* 快*。</p>
<ul>
<li><p>容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>
</li>
<li><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>
</li>
<li><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>
</li>
</ul>
<p>　　下图是docker与传统虚拟机性能对比。<br><img  src="/images/12e0188ee1b32356.png"  ><span class="image-caption">2</span></p>
<p>转自：<br><a href="http://xgfe.github.io/2016/12/21/scliuyang/docker1/?utm_source=tuicool&amp;utm_medium=referral">http://xgfe.github.io/2016/12/21/scliuyang/docker1/?utm_source=tuicool&amp;utm_medium=referral</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>工业时代</tag>
        <tag>集装箱</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言的历史</title>
    <url>/2017/05/10/2017-5-10-history/</url>
    <content><![CDATA[<p>　　一个个字符，随着敲击键盘的哒哒声，经由或是懵懂或是老练的程序员指尖的跃动，最终呈现为显示器上一行行的代码。它们就这样，一行接一行随着回车与换行不停的跳动。那，是眼前这个人悦动的灵魂，它一点一点、一行行慢慢的实现着屏幕前这个程序员的梦想，也一点点，一步步推动着时代的发展，社会的变迁。</p>
<p><img  src="/images/201576105840742.jpg"  ><span class="image-caption">images</span></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>历史</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>2017年PHP程序员未来路在何方</title>
    <url>/2017/05/15/2017-5-15-2017php/</url>
    <content><![CDATA[<p>　　PHP 从诞生到现在已经有20多年历史，从Web时代兴起到移动互联网退潮，互联网领域各种编程语言和技术层出不穷， Node.js 、 GO 、 Python 不断地在挑战 PHP 的地位。这些技术的推动者非常热衷于唱衰 PHP ， PHP 语言的未来在哪里？PHP 程序员当如何应对未来的变革？</p>
<p>　　作为老牌的 Web 后端编程语言，PHP 在全球市场占有率非常高，仅次于 Java ，从各个招聘网站的数据上来看PHP 开发的职位非常多，薪资水平也非常不错。实际在中小企业、互联网创业公司PHP的市场地位是高于 Java 的。Java 在超大型企业、传统软件行业、金融领域优势更大。目前来看 Node.js、 GO 、 Python 、 Ruby 等语言还难以企及 PHP 和 Java 。</p>
<p>　　PHP 语言之所以能有今天的地位，得益于PHP语言设计者一直遵从实用主义，将技术的复杂性隐藏在底层。PHP 语言入门简单，容易掌握，程序健壮性好，不容易出现像 Java 、 C++ 等其他语言那样复杂的问题，如内存泄漏和 Crash ，跟踪调试相对轻松很多。PHP 官方提供的标准库非常强大，各种功能函数都能在官方的标准库中找到，包括MySQL、Memcache、Redis、GD图形库、CURL、XML、JSON等等，免除了开发者到处找库的烦恼。PHP 的文档非常棒，每个函数都有详细的说明和使用示例。第三方类库和工具、代码、项目也很丰富。开发者可以快速、高效地使用 PHP 编写开发各类软件。到目前为止市面上仍然没有出现比 PHP 更简单易用的编程语言。所以 PHP 的前景还是很广阔的，与其纠结于编程语言的选择，不如好好地深入学习使用 PHP 。</p>
<p>　　作为一个资深的 PHP 开发者，在技术上给各位 PHP 程序十点未来的建议，希望对大家有所帮助。</p>
<h2 id="1-Composer"><a href="#1-Composer" class="headerlink" title="1. Composer"></a>1. Composer</h2><p>　　第一点就要提 Composer ，自从 Composer 出现后，PHP 的依赖管理可以变得非常简单。程序内依赖一些类库和框架，直接使用 Composer 引入即可，通过使用 composer update 安装依赖的包。解决了过去加载外部库的各种难题。Composer 也有国内镜像，速度非常快。现在绝大部分PHP开源的项目都提供了 Composer 的支持，建议大家在项目中使用 Composer 来解决 PHP 代码包管理的问题，不要再使用下载源码、手工 include 的原始方法。</p>
<h2 id="2-PHP7"><a href="#2-PHP7" class="headerlink" title="2. PHP7"></a>2. PHP7</h2><p>　　PHP7 版本对 Zend 引擎做了大量修改，大幅提升了 PHP 语言的性能，使用 PHP7 可以使你的程序性能瞬间翻倍。即使是 WordPress 这样重量级的软件运行在 PHP7 都能有上千 QPS ，相当于一台服务器每天就能处理 8000 万次请求。使用 PHP7 ，做好 MySQL 优化，使用 Memcache 和 Redis 进行加速，这套技术架构完全可以应对相当大规模的系统。除了某些亿级用户的平台之外，一般规模的系统完全没有压力。</p>
<h2 id="3-PSR"><a href="#3-PSR" class="headerlink" title="3. PSR"></a>3. PSR</h2><p>　　PSR 是 <a href="http://www.php-fig.org/">http://www.php-fig.org/</a> 组织制定的PHP语言开发规范，约定了很多方面的规则，如命名空间、类名<br>规范、编码风格标准、Autoload、公共接口等。现在已经成为PHP技术社区事实上的标准了。很多知名的 PHP 框架和类库都遵守了 PSR 规范。PHP 开发者应当学习掌握 PSR 规范，在开发程序时应当尽量遵循 PSR 规范。</p>
<h2 id="4-Swoole"><a href="#4-Swoole" class="headerlink" title="4. Swoole"></a>4. Swoole</h2><p>　　2017 年 PHP 还局限于做 Web 网站吗？No ，如果你还不知道 Swoole ，赶快去了解一下吧。Swoole 的口号是重新定义 PHP 语言，Swoole 是一个异步并行的通信引擎，作为 PHP 的扩展来运行。Node.js 的异步回调 Swoole 有，Go语言的协程 Swoole 也有，这完全颠覆了对 PHP 的认知。使用 Swoole PHP 可以实现常驻内存的 Server 程序，可以实现 TCP 、 UDP 异步网络通信的编程开发。过去PHP只能做一个 Web 网站，现在使用 Swoole 可以做 Java 、C++ 才能实现的通信服务，比如 WebSocket 即使通信、聊天、推送服务器、RPC 远程调用服务、网关、代理、游戏服务器等。如果你想用 PHP 做点 Web 系统之外的东西，Swoole 是最好的选择。</p>
<h2 id="5-Laravel"><a href="#5-Laravel" class="headerlink" title="5. Laravel"></a>5. Laravel</h2><p>　　最近几年最火热的 PHP 框架，官网号称是为 Web 艺术家设计的框架，可见这套框架有多优雅。Laravel 提供的功能模块丰富，API 设计简洁，表达力强。而且它的社区非常活跃，代码贡献者众多，第三方的插件非常多，生态系统相当繁荣。 Laravel 底层使用了很多 symfony2 组件，通过 composer 实现了依赖管理。如果还在纠结使用什么PHP框架，不如选择 Laravel 。 Laravel 提供的命令行工具基于 symfony.console 实现，功能强大，集成了各种项目管理、自动生成代码的功能。</p>
<h2 id="6-Phar"><a href="#6-Phar" class="headerlink" title="6. Phar"></a>6. Phar</h2><p>　　PHP5.3 之后支持了类似 Java 的 jar 包，名为 phar。用来将多个 PHP 文件打包为一个文件。这个特性使得 PHP 也可以像 Java 一样方便地实现应用程序打包和组件化。一个应用程序可以打成一个 Phar 包，直接放到<br>PHP-FPM 中运行。配合 Swoole ，可以在命令行下执行 php server.phar 一键启动服务器。PHP 的代码包可以用 Phar 打包成组件，放到 Swoole 的服务器容器中去加载执行。</p>
<h2 id="7-C-C-GO"><a href="#7-C-C-GO" class="headerlink" title="7. C/C++/GO"></a>7. C/C++/GO</h2><p>　　任何技术有优点就有缺点，PHP 作为一门动态脚本语言，优点是开发方便效率高。缺点就是性能差。在密集运算的场景下比 C 、 C++ 相差几十倍甚至上百倍。另外 PHP 不可以直接操作底层，需要依赖扩展库来提供 API 实现。PHP 程序员可以学习一门静态编译语言作为补充实现动静互补，C/C++/Go 都是不错的选择。而且静态语言的编程体验与动态语言完全不同，学习过程可以让你得到更大的提升。</p>
<p>　　掌握 C/C++ 语言后，还可以阅读 PHP 、 Swoole 、 Nginx 、Redis 、 Linux内核 等开源软件的源码，了解其底层运行原理。</p>
<p>　　现在最新版本的Swoole提供了C++扩展模块的支持，封装了Zend API，用C++操作PHP变得很简单，可以用C++实现PHP扩展函数和类。</p>
<h2 id="8-HTML5"><a href="#8-HTML5" class="headerlink" title="8. HTML5"></a>8. HTML5</h2><p>　　作为 Web 前端新一代标准，HTML5 未来前景非常广阔，市场需求量非常大。从 PC 网站、B/S 企业软件、移动端网页、APP，这些领域都在拥抱 HTML5，掌握了 HTML5 才能在下一波互联网技术大潮中存活下来。</p>
<h2 id="9-Vue-js"><a href="#9-Vue-js" class="headerlink" title="9. Vue.js"></a>9. Vue.js</h2><p>　　PHP 程序员除了写后台程序之外，还有很大一部分工作在展现层，和浏览器前端打交道。2017 年你还在用 jQuery 操作 DOM 实现界面渲染吗？已经完全 out 了。现在用 Vue.js 可以非常方便地实现数据和 DOM 元素的绑定。通过 Ajax 请求后台接口返回数据后，更新前端数据自动实现界面渲染。2017 年再不学 Vue 就晚了。</p>
<p>　　如果你不光要写 Web 程序，同时还希望兼顾 Android 、IOS 、PC 客户端等平台，React Native 是一个不错的选择。</p>
<h2 id="10-深度学习-人工智能"><a href="#10-深度学习-人工智能" class="headerlink" title="10. 深度学习/人工智能"></a>10. 深度学习/人工智能</h2><p>　　互联网的未来属于人工智能，如果你还不了解机器学习、深度学习、人工智能这些概念，那你需要尽快学习了解一下。现在互联网巨头们都在布局人工智能，包括 Google 、 Facebook 、微软、亚马逊 和国内的百度。虽然现在还处于科学研究的阶段，但未来互联网的各个领域都会应用到人工智能，包括自动驾驶、大数据分析、网络游戏、图像识别、语言处理等。当然现在普通的工程师可能还无法参与到人工智能产品中，但至少应该理解深度学习/人工智能的基本概念和原理。</p>
<p>来源：segmentfault 作者：韩天峰（matyhtf）</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>人工智能</tag>
        <tag>Swoole</tag>
      </tags>
  </entry>
  <entry>
    <title>利用dockerfile快速搭建php+nginx+mysql环境</title>
    <url>/2017/05/01/2017-5-2-docker/</url>
    <content><![CDATA[<p>　　利用dockerfile快速搭建php+nginx+mysql环境<br>    <a href="https://github.com/lincome/dockerfile_php_nginx_mysql">github链接</a></p>
<hr>
<h1 id="dockerfile-php-nginx-mysql"><a href="#dockerfile-php-nginx-mysql" class="headerlink" title="dockerfile_php_nginx_mysql"></a>dockerfile_php_nginx_mysql</h1><p>docker环境php7、nginx1、mysql5.5</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>从阿里云拉取镜像</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">docker pull registry.cn-hangzhou.aliyuncs.com<span class="hljs-regexp">/linqr/</span>php_nginx_mysql<br></code></pre></td></tr></table></figure>

<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>通过dockerfile重建你需要的环境镜像</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> build -t nginx_php_mysql:v<span class="hljs-number">3</span> .<br></code></pre></td></tr></table></figure>

<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>创建容器</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -itv /blog<span class="hljs-number">1</span>:/user/share/nginx/html --add-host sfc<span class="hljs-number">5</span>.com:<span class="hljs-number">192.168.99.100</span> -p <span class="hljs-number">9999</span>:<span class="hljs-number">80</span> -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> --privileged --name php_nginx_<span class="hljs-number">5</span><span class="hljs-meta"> [镜像id]</span><br></code></pre></td></tr></table></figure>

<p>进入容器</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> [容器<span class="hljs-built_in">id</span>] bash<br></code></pre></td></tr></table></figure>
<p>开启mysql服务</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">service mysql <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure>
<p>mysql默认账号root、密码root</p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>访问站点<br>sfc5.com/192.168.99.100:9999</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>dockerfile</tag>
        <tag>php</tag>
        <tag>nginx</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么把梳子卖给和尚？这个故事太有启发了！</title>
    <url>/2017/05/31/2017-5-31-simhs/</url>
    <content><![CDATA[<p>　　有一个营销经理想考考他的手下，就给他们出了一道题，把梳子卖给和尚。</p>
<h2 id="第一个人"><a href="#第一个人" class="headerlink" title="第一个人"></a>第一个人</h2><p>　　出了门就骂，什么狗经理，和尚都没有头发，还卖什么梳子！找个酒馆喝起了闷酒，睡了一觉，会去告诉经理，和尚没有头发，梳子无法卖！经理微微一笑，和尚没有头发还需要你告诉我？</p>
<h2 id="第二个人"><a href="#第二个人" class="headerlink" title="第二个人"></a>第二个人</h2><p>　　来到了一个寺庙，找到了和尚，对和尚说，我想卖给你一把梳子，和尚说，我没用。那人就把经理的作业说了一遍，说如果卖不出去，就会失业，你要发发慈悲啊！和尚就买了一把。</p>
<h2 id="第三个人"><a href="#第三个人" class="headerlink" title="第三个人"></a>第三个人</h2><p>　　也来到一个寺庙卖梳子，和尚说，真的不需要的。那人在庙里转了转，对和尚说，拜佛是不是要心诚，和尚说，是的。心诚是不是需要心存敬意， 和尚说，要敬。<br>那人说，你看，很多香客很远来到这里，他们十分虔诚，但是却风尘仆仆，蓬头垢面，如何对佛敬？如果庙里买些梳子，给这些香客把头发梳整齐了，把脸洗干净了，不是对佛的尊敬？和尚话说有理，就买了十把。</p>
<h2 id="第四个人"><a href="#第四个人" class="headerlink" title="第四个人"></a>第四个人</h2><p>　　也来到一个寺庙卖梳子，和尚说，真的不需要的。那人对和尚说，如果庙里备些梳子作为礼物送给香客，又实惠、又有意义，香火会更旺的，和尚想了想，有道理，就买了100把。</p>
<h2 id="第五个人"><a href="#第五个人" class="headerlink" title="第五个人"></a>第五个人</h2><p>　　也来到一个寺庙卖梳子，和尚说，真的不需要的。那人对和尚说，你是得道高僧，书法甚是有造诣，如果把您的字刻在梳子上，刻些“平安梳”、“积善梳”送给香客，是不是既弘扬了佛法，又弘扬了书法，老和尚微微一笑，无量佛！就买了1000把梳子。</p>
<h2 id="第六个人"><a href="#第六个人" class="headerlink" title="第六个人"></a>第六个人</h2><p>　　也来到一个寺庙卖梳子，和尚说，真的不需要的。那人个和尚说了一番话，却卖出了一万把梳子。<br>那人说了些什么？<br>　　他告诉和尚，梳子是善男信女的必备之物，经常被女香客带是在身上，如果大师能为梳子开光，成为她们的护身符，既能积善行善、又能保佑平安，很多香客还能为自己的亲朋好友请上一把，保佑平安，弘扬佛法，扬我寺院之名，岂不是天大善事？大师岂有不做之理？阿弥陀佛，善哉！善哉！大师双手合十，施主有这番美意， 老衲岂能不从？<br>　　就这样，寺院买了一万把，取名“积善梳”、“平安梳”，由大师亲自为香客开光，竟十分兴隆。当然，开光所捐的善款也不菲啊！</p>
<h1 id="评论小结"><a href="#评论小结" class="headerlink" title="评论小结"></a>评论小结</h1><ul>
<li>第一个人受传统观念的束缚太厉害，用常理去考虑销售，是不适合做销售的。</li>
<li>第二个人是在卖同情心，这是最低级的销售方法，叫“叩头营销”，是不能长久的。</li>
<li>第三、四个人为客户着想，可以说是“顾客满意战略”，自然会有好的效果。</li>
<li>第五人不仅能够然顾客满意，还能迎合顾客心理，自然就会不会差。</li>
<li>第六人就已经达到了物我两重天的境界，不是在卖梳子，而是在卖护身符，把顾客的价值最大化，自然也就不足为奇了。</li>
</ul>
<p>　　前五个人都回去给经理报到了，第六个人没有回去。他去找更多的寺院，他发掘到了一个市场，他要自己干。自然，他成功了，他成千上万的向一个一个寺院卖梳子，掘到了第一桶金。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>梳子</tag>
        <tag>和尚</tag>
        <tag>销售</tag>
      </tags>
  </entry>
  <entry>
    <title>new world</title>
    <url>/2017/05/05/2017-5-5-neworld/</url>
    <content><![CDATA[<p>　　“既然上班是一种煎熬，为什么不离职呢？”长久以来一直萦绕在心头的一个问题。。。再等等，下个月就离，先过了这个月再说！有人为了家庭，有人为了生计，可却有人不知道为了什么，既没有家庭，也没生计的困扰，可还是宁愿待在岗位上不动，宁愿就这么待着，明知不喜欢这份工作，它也不会给自己带来明天，也不知道整天待在这个岗位上是为了什么?</p>
<p>　　作为一个人必须要清楚自己的目标，向着目标不断前行，不断将自己推向目的地，无论路上多少荆棘，永不言弃。</p>
<pre><code>有志者，事竟成，破釜沉舟，百二秦关终属楚
苦心人，天不负，卧薪尝胆，三千越甲可吞吴

                              ——蒲松龄撰 自勉联
</code></pre>
]]></content>
      <categories>
        <category>职业生涯</category>
      </categories>
      <tags>
        <tag>职业生涯</tag>
        <tag>上班族</tag>
        <tag>离职</tag>
      </tags>
  </entry>
  <entry>
    <title>दंगल（摔跤吧!爸爸）</title>
    <url>/2017/05/06/2017-5-6-sjbbb/</url>
    <content><![CDATA[<p>　　感人至深的电影了，到电影快结束的时候，电影院竟然一度听到了掌声，为主角的女儿最终赢得摔跤冠军而鼓掌，观影期间多次让人哽咽，回忆下：</p>
<ul>
<li>剪掉女儿的长发</li>
<li>大女儿把父亲打败的那刻</li>
<li>大女儿重新回到父亲怀抱的那通电话</li>
<li>女儿即将被开除出校，父亲的哀求</li>
<li>大女儿最后将澳大利亚冠军摔倒反败为胜的最后一刻</li>
</ul>
]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>感动</tag>
        <tag>运动</tag>
        <tag>阿米尔汗</tag>
      </tags>
  </entry>
  <entry>
    <title>四种常见的 POST 提交数据方式</title>
    <url>/2017/05/08/2017-5-9-post/</url>
    <content><![CDATA[<p>　　HTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，本文主要讨论 POST 提交数据的几种方式。</p>
<ul>
<li>application/x-www-form-urlencoded(默认)</li>
<li>multipart/form-data</li>
<li>application/json</li>
<li>text/xml</li>
</ul>
<p>　　在跨域的时候，除了contentType为application/x-www-form-urlencoded, multipart/form-data或者text/plain外，都会触发浏览器先发送方法为OPTIONS的请求。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>POST</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP标准规范</title>
    <url>/2017/06/24/2017-6-24-psr/</url>
    <content><![CDATA[<p>　　近段时间在做一个团购系统的二次开发，发现各种方法、变量等的命名、框架技术太陈旧了，如果人人都能够用标准的php规范（psr1~4）来编码，那这个世界就清净多了！</p>
<p>类的常量、属性和方法</p>
<ul>
<li><p>类的常量中所有字母都 必须 大写，词间以下划线分隔。</p>
</li>
<li><p>类的属性命名 可以遵循：</p>
<ul>
<li>大写开头的驼峰式 ($StudlyCaps)</li>
<li>小写开头的驼峰式 ($camelCase)</li>
<li>下划线分隔式 ($under_score)</li>
</ul>
</li>
<li><p>方法名称 必须 符合 camelCase() 式的小写开头驼峰命名规范。</p>
</li>
</ul>
<hr>
<p>PHP 标准规范：<a href="https://psr.phphub.org/">PHP 标准规范</a>。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>psr</tag>
        <tag>标准</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>短歌行</title>
    <url>/2017/07/13/2017-7-13-dgx/</url>
    <content><![CDATA[<p>对酒当歌，人生几何！譬如朝露，去日苦多。</p>
<p>慨当以慷，忧思难忘。何以解忧？唯有杜康。</p>
<p>青青子衿，悠悠我心。但为君故，沉吟至今。</p>
<p>呦呦鹿鸣，食野之苹。我有嘉宾，鼓瑟吹笙。</p>
<p>明明如月，何时可掇？忧从中来，不可断绝。</p>
<p>越陌度阡，枉用相存。契阔谈讌，心念旧恩。</p>
<p>月明星稀，乌鹊南飞。绕树三匝，何枝可依？</p>
<p>山不厌高，海不厌深。周公吐哺，天下归心。</p>
<hr>
<p>曹操一生求贤若渴，才华横溢！伟大的政治家、诗人！</p>
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>曹操</tag>
        <tag>司马懿</tag>
        <tag>曹丕</tag>
      </tags>
  </entry>
  <entry>
    <title>女儿情</title>
    <url>/2017/07/23/2017-7-23-neq/</url>
    <content><![CDATA[<p>鸳鸯双栖蝶双飞</p>
<p>满园春色惹人醉</p>
<p>悄悄问圣僧</p>
<p>女儿美不美</p>
<p>女儿美不美</p>
<p>说什么王权富贵</p>
<p>怕什么戒律清规</p>
<p>只愿天长地久</p>
<p>与我意中人儿紧相随</p>
<p>爱恋依 爱恋依</p>
<p>愿今生长相随</p>
<p>愿今生长相随</p>
<p>长相随</p>
<hr>
<p>好听！</p>
]]></content>
      <categories>
        <category>歌曲</category>
      </categories>
      <tags>
        <tag>女儿情</tag>
        <tag>越云鹏</tag>
        <tag>西游记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/03/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>hexo博客搬迁到solo啦</title>
    <url>/2019/10/14/201910/hexo%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%BF%81%E5%88%B0solo%E5%95%A6/</url>
    <content><![CDATA[<p>试用下看看好用不，两年没写了，时间过的太快了！</p>
]]></content>
      <tags>
        <tag>迁移</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>人是怎么废掉的？</title>
    <url>/2019/10/20/201910/%E4%BA%BA%E6%98%AF%E6%80%8E%E4%B9%88%E5%BA%9F%E6%8E%89%E7%9A%84/</url>
    <content><![CDATA[<p><img src="https://img.hacpai.com/bing/20180607.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"></p>
<p><strong>人是怎么废掉的？</strong></p>
<p>01</p>
<p><strong>沉溺于「轻易获得高成就感」的事情</strong></p>
<p>有意无意地寻求用很小付出获得很大「回报」的偏方，哪怕回报是虚拟的。这种行为会提升自己的「兴奋阈值」，让人越来越不容易拥有成就感，从而越来越依赖虚拟的成就感，陷入恶性循环。</p>
<p>症状轻的<strong>：沉溺游戏</strong>（在虚拟世界中加快时间流逝的速度，使得「成功」来得更快）、<strong>种马小说</strong>（意淫人能轻易获得想要的东西）；</p>
<p>症状重甚至犯法的：<strong>赌博</strong>（轻易获得「金钱」）、<strong>吸毒</strong>（轻易获得「爽」的感觉）等。</p>
<p>02</p>
<p><strong>只接收「低信息密度」的信息源</strong></p>
<p>只愿意接收信息密度低的信息（如无需太多动脑的视频、图片，以及深度较浅的娱乐、八卦、体育新闻等）。</p>
<p>不愿意接收信息密度高、需要思考后才能吸收的信息（如课程、知识框架、分析报告等）。</p>
<p>由于真正有价值、能让人进步的信息大多是需要思考和消化的，所以如果完全隔离了这部分内容，基本也就隔离了进步的可能。</p>
<p>03</p>
<p><strong>习惯用「错位成就感」麻痹自己</strong></p>
<p>有两类：① 习惯于拿自己擅长的东西和别人不擅长的东西比较，从来获得「比别人强」的错觉（如：和运动员比学习成绩，和学霸比体育）；</p>
<p>② 习惯于拿别人做事情 A 的时间来做事情 B，来假装自己在事情 B 上做得好（如：「炫耀」自己在节假日做了比别人更多的工作，但也仅仅是在节假日才能如此）。</p>
<p>04</p>
<p><strong>过度依赖「既有可行路径」</strong></p>
<p>在工作中，习惯了一件事情的流程后再也没想过如何改进，只会机械地重复，然后骗自己很充实。</p>
<p>没有改进，便也没有剔除糟粕的意识，于是需要重复的东西越来越多，消耗时间也越来越长，到最后，看上去每天做了很多事情，但其实不仅一点进步都没有，还挤占了进步的空间。</p>
<p>05</p>
<p><strong>封闭「强化学习」的通道</strong></p>
<p>在学习或接受信息中，只愿意执行最简单的第一步，却不愿意执行接下来更为复杂的巩固和应用流程，只听不说、只看不写、只学不练，还麻痹自己说学到了很多东西，而实际上，这种「浅层」的学习遗忘极快，有时还不如不学。</p>
<p>比如，天天学英语，却从不写英语文章；再比如，天天刷知乎，却从不写答案、写总结。</p>
<hr>
<ol>
<li><p>当你给自己画了个圈圈，还永不逾越的时候。</p>
</li>
<li><p>当你觉得在你的家族里，就出了你一个大学生，仅仅本科毕了业也很厉害的时候。</p>
</li>
<li><p>当你觉得你家里没有门路，比不上那些家里走后门，有门路的同学而自暴自弃的时候。</p>
</li>
<li><p>当你觉得自己家里人脉广泛，家里财力富余的时候而不思进取的时候。</p>
</li>
<li><p>当你觉得下次努力就好的时候。</p>
</li>
<li><p>当你习惯把今天的事情放到明天做的时候。</p>
</li>
<li><p>当你今天还做不完昨天的事情，还要放到明天去做的时候。</p>
</li>
<li><p>当你总是在碰到困难时安慰自己，觉得自己比我那些没上高中的初中同学，没上大学的高中同学强多了的时候。</p>
</li>
</ol>
<p>转载至：<a href="https://mp.weixin.qq.com/s/6tG9-b_mcIQkyJdcu5mJmQ">https://mp.weixin.qq.com/s/6tG9-b_mcIQkyJdcu5mJmQ</a></p>
]]></content>
      <tags>
        <tag>积极强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>在搬砖的路上越走越远</title>
    <url>/2019/10/17/201910/%E5%9C%A8%E6%90%AC%E7%A0%96%E7%9A%84%E8%B7%AF%E4%B8%8A%E8%B6%8A%E8%B5%B0%E8%B6%8A%E8%BF%9C/</url>
    <content><![CDATA[<p><img src="https://img.hacpai.com/bing/20180411.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"> </p>
<h2 id="我所经历的三次裁员"><a href="#我所经历的三次裁员" class="headerlink" title="我所经历的三次裁员"></a>我所经历的三次裁员</h2><p>先从一则新闻说起：</p>
<blockquote>
<p>人民网旧金山9月19日电(邓圩 宫欣)当地时间9月19日，位于旧金山湾区Menlo Park的Facebook总部内，一名男子从园区内的一栋办公楼4楼跳下，现场死亡。</p>
<p>当天下午，Facebook发布声明证实死者为该公司的一名员工，系自杀身亡，目前已经通知了该员工家人。</p>
</blockquote>
<p>可能是类似的事情发生的较多，这个事件并没有引起多大反响。直到最近<strong>Facebook华裔员工为自杀同胞求真相遭无理开除</strong>，事件才得以发酵，引发了广泛的关注，许多媒体开始发声。关于这个事件，我其实也没有什么好说，只想借我所亲历的三次裁员，谈谈我的想法。</p>
<p>第一次裁员发生在2009年，那时我已经三十好几，传说中程序员年龄的上限。公司当时裁掉的是做导航产品的部门，主要原因还不是因为智能手机的冲击，而是做民用终端产品，无法和广东那边的厂家竞争。当然智能手机取代车载导航，也是后来的事情，公司领导当时也看得比较明白，趋势无法阻挡，所以裁员非常彻底，一锅端了。</p>
<p>第二次裁员发生在2016年，彼时我已年届不惑之年。这次裁员原因很简单，就是有钱的时候拼命招人，最后钱烧完了，没法养这么多人，只好精简。每个项目组都精简一部分人，最后加上自愿走的，差不多有一半，幅度还是相当大。</p>
<p>第三次裁员发生在2017年年底，这次裁员是因为上次裁过之后，公司仍然没有起色，本来期望和特殊部门合作的项目，也黄了，只好砍掉一些产品线。所以这次裁员也比较粗暴，直接干掉了几个项目组，从上到下，无一幸免。</p>
<p>经历了这几次裁员，也算是过来人，所以想谈谈对裁员的看法。</p>
<p>首先，裁员可能并不是我们想象的那样，是因为工作不努力或者能力差，有时真是因为一些不可控原因，比如碰上公司转型、精简产品线，就像我经历的第一次和第三次裁员，都是从上到下一锅端，并不会因为能力强或者人际关系留下。所以，以后如果大家在招聘过程中看到有因为裁员而求职的，不要有歧视，也许别人只是运气不好。而被裁的人，更不要怀疑自己，觉得是因为自己哪里做的不够好，也许是因为你太优秀了，所以现在才不需要你。如果走出去，也许会看到更大的世界，开拓一片新天地。</p>
<p>其次，我们也要弄清楚个人和企业之间的关系。国庆节看了《我和我的祖国》，其中有一个片段，是讲张译饰演的科研人员，冒着生命危险挽救了一场事故，而因此遭辐射致死。看到这一段，我也很感动，当时研究原子弹的科研人员，因为保密原因，和亲人都无法联系，一心扑在工作上，才有原子弹的诞生，的确令人钦佩。但时代不同，个人和企业之间的关系也发生了很大的变化，变成了雇佣关系。通俗来讲，就是拿钱办事，互不两欠。在现代企业，还冒着生命生命危险去挽救公司财产，那才是脑子进水了。如果厘清了个人和企业之间的关系，不妨以平常心看待裁员，无非是企业不再需要我们，不愿意付钱购买我们的工作时间，也许从情感上讲，有些不近情理。但我们如果反过来想，如果个人因为一些原因辞职，企业和你谈情感，百般阻拦，你是不是也会觉得这家企业有毛病？所以，碰到裁员，不要觉得特别憋屈，好像全世界对不起你。拿到赔偿金，潇洒的走人。如果企业不付赔偿金，违反劳动法，那是另外一个话题，这里就不展开。</p>
<p>为什么现代企业不像以前那样实行终身制？这是总结了无数失败的案例，才得到现在的企业制度。想想以前的大锅饭，吃着吃着，锅里就没饭了。那种终身制，只适合集中能力干大事的时期，在民用领域，还是竞争促进发展，最为高效。如果你还觉得进一个企业干终身比较好，可以看看隔壁的日本，年轻人没有上升通道，才是一件令人绝望的事情。</p>
<p>最后，之前发生的几次裁员自杀事件，都是压力过大导致的。这就要求个人不要超出自己负担能力，就如同程序设计一样，留一点冗余。年轻人给自己一点压力不是一点坏事，但这个度最好不要超过自身能力太多。这就如同你平常跑步能跑3公里，下次可以增加到5公里，但不要一下子加码到10公里。对于年轻人来说，最大的负担可能就是买房，需要规划一下首付如何付，月供能承担多少。如果你能负担起100万的房子，咬咬牙也许可以冲击一下150万左右的，但一下子就跳到200万，那就有些过分了。至于什么网贷，就别碰了，那不是普通人能够hold住的。另外预留一两个月的月供和生活费也是必须的，以防遭到裁员，一下子没有经济来源，而生活崩溃。即使真的沦落到无钱还房贷和缺少生活费的地步，也请脸皮放厚一点，向父母、亲戚朋友求援。</p>
<p>最后的最后，当然是提高自身能力，让你有能力快速找到下一份工作。在这个社会，只要不懒，没病没痛，一份糊口的工作还是百分之百可以找到。</p>
<p>BTW，保持身体健康也很重要，所以和我一样，跑起来吧！</p>
<p>转载自：<a href="https://mp.weixin.qq.com/s/d-T6XRGdDl_YJ2Jvu88i2w">https://mp.weixin.qq.com/s/d-T6XRGdDl_YJ2Jvu88i2w</a></p>
]]></content>
      <tags>
        <tag>裁员</tag>
        <tag>知己知彼</tag>
      </tags>
  </entry>
  <entry>
    <title>我在 GitHub 上的开源项目</title>
    <url>/2019/10/14/201910/%E6%88%91%E5%9C%A8GitHub%E4%B8%8A%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<!-- 该页面会被定时任务自动覆盖，所以请勿手工更新 -->
<!-- 如果你有更漂亮的排版方式，请发 issue 告诉我们 -->

<h3 id="1-sfc-PHP-🤩0-nbsp-nbsp-⭐️4-nbsp-nbsp-🖖3"><a href="#1-sfc-PHP-🤩0-nbsp-nbsp-⭐️4-nbsp-nbsp-🖖3" class="headerlink" title="1. sfc PHP 🤩0&nbsp;&nbsp;⭐️4&nbsp;&nbsp;🖖3"></a>1. <a href="https://github.com/lincome/sfc">sfc</a> <kbd title="主要编程语言">PHP</kbd> <span style="font-size: 12px;"><a href="https://github.com/lincome/sfc/watchers" title="关注数">🤩<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/lincome/sfc/stargazers" title="收藏数">⭐️<code>4</code></a>&nbsp;&nbsp;<a href="https://github.com/lincome/sfc/network/members" title="分叉数">🖖<code>3</code></a></span></h3><p>laravel5.4+vue2.0开发的顺风车及后台</p>
<hr>
<h3 id="2-jxc-🤩0-nbsp-nbsp-⭐️1-nbsp-nbsp-🖖0"><a href="#2-jxc-🤩0-nbsp-nbsp-⭐️1-nbsp-nbsp-🖖0" class="headerlink" title="2. jxc  🤩0&nbsp;&nbsp;⭐️1&nbsp;&nbsp;🖖0"></a>2. <a href="https://github.com/lincome/jxc">jxc</a> <kbd title="主要编程语言"></kbd> <span style="font-size: 12px;"><a href="https://github.com/lincome/jxc/watchers" title="关注数">🤩<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/lincome/jxc/stargazers" title="收藏数">⭐️<code>1</code></a>&nbsp;&nbsp;<a href="https://github.com/lincome/jxc/network/members" title="分叉数">🖖<code>0</code></a></span></h3><hr>
<h3 id="3-to-live-🤩0-nbsp-nbsp-⭐️1-nbsp-nbsp-🖖0"><a href="#3-to-live-🤩0-nbsp-nbsp-⭐️1-nbsp-nbsp-🖖0" class="headerlink" title="3. to-live  🤩0&nbsp;&nbsp;⭐️1&nbsp;&nbsp;🖖0"></a>3. <a href="https://github.com/lincome/to-live">to-live</a> <kbd title="主要编程语言"></kbd> <span style="font-size: 12px;"><a href="https://github.com/lincome/to-live/watchers" title="关注数">🤩<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/lincome/to-live/stargazers" title="收藏数">⭐️<code>1</code></a>&nbsp;&nbsp;<a href="https://github.com/lincome/to-live/network/members" title="分叉数">🖖<code>0</code></a></span></h3><p>活着(余华)</p>
<hr>
<h3 id="4-solo-blog-🤩0-nbsp-nbsp-⭐️0-nbsp-nbsp-🖖0-nbsp-nbsp-🏠https-blog-recordsmylife-com"><a href="#4-solo-blog-🤩0-nbsp-nbsp-⭐️0-nbsp-nbsp-🖖0-nbsp-nbsp-🏠https-blog-recordsmylife-com" class="headerlink" title="4. solo-blog  🤩0&nbsp;&nbsp;⭐️0&nbsp;&nbsp;🖖0&nbsp;&nbsp;🏠https://blog.recordsmylife.com"></a>4. <a href="https://github.com/lincome/solo-blog">solo-blog</a> <kbd title="主要编程语言"></kbd> <span style="font-size: 12px;"><a href="https://github.com/lincome/solo-blog/watchers" title="关注数">🤩<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/lincome/solo-blog/stargazers" title="收藏数">⭐️<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/lincome/solo-blog/network/members" title="分叉数">🖖<code>0</code></a>&nbsp;&nbsp;<a href="https://blog.recordsmylife.com/" title="项目主页">🏠<code>https://blog.recordsmylife.com</code></a></span></h3><p>lincome 的个人博客 - 记录精彩的程序人生</p>
<hr>
<h3 id="5-Localization-of-Gmail-🤩0-nbsp-nbsp-⭐️0-nbsp-nbsp-🖖0"><a href="#5-Localization-of-Gmail-🤩0-nbsp-nbsp-⭐️0-nbsp-nbsp-🖖0" class="headerlink" title="5. Localization-of-Gmail  🤩0&nbsp;&nbsp;⭐️0&nbsp;&nbsp;🖖0"></a>5. <a href="https://github.com/lincome/Localization-of-Gmail">Localization-of-Gmail</a> <kbd title="主要编程语言"></kbd> <span style="font-size: 12px;"><a href="https://github.com/lincome/Localization-of-Gmail/watchers" title="关注数">🤩<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/lincome/Localization-of-Gmail/stargazers" title="收藏数">⭐️<code>0</code></a>&nbsp;&nbsp;<a href="https://github.com/lincome/Localization-of-Gmail/network/members" title="分叉数">🖖<code>0</code></a></span></h3><p>Localization of Gmail</p>
]]></content>
      <tags>
        <tag>开源</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>送我上青云</title>
    <url>/2019/11/03/201911/%E9%80%81%E6%88%91%E4%B8%8A%E9%9D%92%E4%BA%91/</url>
    <content><![CDATA[<h2 id="enjoy-your-life"><a href="#enjoy-your-life" class="headerlink" title="enjoy your life"></a>enjoy your life</h2><p>每个周末开始都是从消沉的意志开始，爬了两天山，呼吸室外新鲜空气得以重生，胡思乱想了很多很多，唯有今晚的电影让我彻底的缓过神来，被癌症影响的主人公还可以如此乐观，不自卑的骄傲的活着，被背圆周率的文艺男弄笑的不行，笑着的心却是极寒的，一定要自己决定自己的人生，要有足够的底气去掌控自己的人生，不低头，勇往直前，，，同时不做“有德无才”的stupid，害人害己！</p>
<p>奇怪的是将ios的siri语言设置为英文之后，一直 say “hey siri” 无法识别到，语言能力变得越来越脆弱了，have a good night and sweet dreams.</p>
]]></content>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿门宴</title>
    <url>/2019/11/10/201911/%E9%B8%BF%E9%97%A8%E5%AE%B4/</url>
    <content><![CDATA[<h2 id="兴趣使然，画个故事脑图"><a href="#兴趣使然，画个故事脑图" class="headerlink" title="兴趣使然，画个故事脑图"></a>兴趣使然，画个故事脑图</h2><p>感叹中华文化博大精深，勾心斗角永无止境<br><a href="http://naotu.baidu.com/file/9a7e19e5979e0dbed48a56efd6ef12fb?token=a8bd1c9f070c4bde">点击查看鸿门宴</a></p>
]]></content>
      <tags>
        <tag>楚汉相争鸿门宴</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观勇敢的活着</title>
    <url>/2019/12/18/201912/%E4%B9%90%E8%A7%82%E5%8B%87%E6%95%A2%E7%9A%84%E6%B4%BB%E7%9D%80/</url>
    <content><![CDATA[<h2 id="2019即将过去，焦虑不断升级，用多年前一本书上的一段话镇定自己。"><a href="#2019即将过去，焦虑不断升级，用多年前一本书上的一段话镇定自己。" class="headerlink" title="2019即将过去，焦虑不断升级，用多年前一本书上的一段话镇定自己。"></a>2019即将过去，焦虑不断升级，用多年前一本书上的一段话镇定自己。</h2><blockquote>
<p>我喜欢我自己，我就是我。没有比这更美好段了，包括我的出生、我的生长，我因为我就是我而庆幸。无论我生在什么时代，我都不愿成为别的什么人，而只愿成为自己。</p>
</blockquote>
]]></content>
      <tags>
        <tag>乐观</tag>
        <tag>积极</tag>
      </tags>
  </entry>
  <entry>
    <title>服务端I/O性能大比拼：Node、PHP、Java和Go</title>
    <url>/2017/06/08/2017-6-8-phpvsgo/</url>
    <content><![CDATA[<p>原文请见：<a href="https://www.toptal.com/back-end/server-side-io-performance-node-php-java-go">Server-side I/O Performance: Node vs. PHP vs. Java vs. Go</a>。</p>
<p>理解应用程序的输入/输出（I/O）模型，意味着其在计划处理负载与残酷的实际使用场景之间的差异。若应用程序比较小，也没有服务于很高的负载，也许它影响甚微。但随着应用程序的负载逐渐上涨，采用错误的I/O模型有可能会让你到处踩坑，伤痕累累。</p>
<p>正如大部分存在多种解决途径的场景一样，重点不在于哪一种途径更好，而是在于理解如何进行权衡。让我们来参观下I/O的景观，看下可以从中窃取点什么。</p>
<p><img  src="/images/62414141f3b3627e6f8dacbea29f0.jpg"  ><span class="image-caption">a</span></p>
<p>在这篇文章，我们将会结合Apache分别比较Node，Java，Go，和PHP，讨论这些不同的语言如何对他们的I/O进行建模，各个模型的优点和缺点，并得出一些初步基准的结论。如果关心你下一个Web应用的I/O性能，那你就找对文章了。</p>
<h2 id="I-O基础知识：快速回顾"><a href="#I-O基础知识：快速回顾" class="headerlink" title="I/O基础知识：快速回顾"></a>I/O基础知识：快速回顾</h2><p>为了理解与I/O密切相关的因素，必须先来回顾在操作系统底层的概念。虽然不会直接处理这些概念的大部分，但通过应用程序的运行时环境你一直在间接地处理他们。而关键在于细节。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>首先，我们有系统调用，它可以描述成这样：</p>
<ul>
<li>你的程序（在“用户区域”，正如他们所说的）必须让操作系统内核在它自身执行I/O操作。</li>
<li>“系统调用”（syscall）意味着你的程序要求内核做某事。不同的操作系统，实现系统调用的细节有所不同，但基本的概念是一样的。这将会有一些特定的指令，把控制权从你的程序转交到内核（类似函数调用但有一些专门用于处理这种场景的特殊sauce）。通常来说，系统调用是阻塞的，意味着你的程序需要等待内核返回到你的代码。</li>
<li>内核在我们所说的物理设备（硬盘、网卡等）上执行底层的I/O操作，并回复给系统调用。在现实世界中，内核可能需要做很多事情才能完成你的请求，包括等待设备准备就绪，更新它的内部状态等，但作为一名应用程序开发人员，你可以不用关心这些。以下是内核的工作情况。</li>
</ul>
<p><img  src="/images/f79a78eb5c6c419aec0971955cc31.jpg"  ><span class="image-caption">b</span></p>
<h2 id="阻塞调用与非阻塞调用"><a href="#阻塞调用与非阻塞调用" class="headerlink" title="阻塞调用与非阻塞调用"></a>阻塞调用与非阻塞调用</h2><p>好了，我刚刚在上面说系统调用是阻塞的，通常来说这是对的。然而，有些调用被分类为“非阻塞”，意味着内核接收了你的请求后，把它放进了队列或者缓冲的某个地方，然后立即返回而并没有等待实际的I/O调用。所以它只是“阻塞”了一段非常短的时间，短到只是把你的请求入列而已。</p>
<p>这里有一些有助于解释清楚的（Linux系统调用）例子：-read()是阻塞调用——你传给它一个文件句柄和一个存放所读到数据的缓冲，然后此调用会在当数据好后返回。注意这种方式有着优雅和简单的优点。-epoll_create()，epoll_ctl()，和epoll_wait()这些调用分别是，让你创建一组用于侦听的句柄，从该组添加/删除句柄，和然后直到有活动时才阻塞。这使得你可以通过一个线程有效地控制一系列I/O操作。如果需要这些功能，这非常棒，但也正如你所看到的，使用起来当然也相当复杂。</p>
<p>理解这里分时差异的数量级是很重要的。如果一个CPU内核运行在3GHz，在没有优化的情况下，它每秒执行30亿次循环（或者每纳秒3次循环）。非阻塞系统调用可能需要10纳秒这样数量级的周期才能完成——或者“相对较少的纳秒”。对于正在通过网络接收信息的阻塞调用可能需要更多的时间——例如200毫秒（0.2秒）。例如，假设非阻塞调用消耗了20纳秒，那么阻塞调用消耗了200,000,000纳秒。对于阻塞调用，你的程序多等待了1000万倍的时间。</p>
<p><img  src="/images/2c535867b3c829329692d3b8a1a21.jpg"  ><span class="image-caption">c</span></p>
<p>内核提供了阻塞I/O（“从网络连接中读取并把数据给我”）和非阻塞I/O（“当这些网络连接有新数据时就告诉我”）这两种方法。而使用何种机制，对应调用过程的阻塞时间明显长度不同。</p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>接下来第三件关键的事情是，当有大量线程或进程开始阻塞时怎么办。</p>
<p>出于我们的目的，线程和进程之间没有太大的区别。实际上，最显而易见的执行相关的区别是，线程共享相同的内存，而每个进程则拥有他们独自的内存空间，使得分离的进程往往占据了大量的内存。但当我们讨论调度时，它最终可归结为一个事件清单（线程和进程类似），其中每个事件需要在有效的CPU内核上获得一片执行时间。如果你有300个线程正在运行并且运行在8核上，那么你得通过每个内核运行一段很短的时间然后切换到下一个线程的方式，把这些时间划分开来以便每个线程都能获得它的分时。这是通过“上下文切换”来实现的，使得CPU可以从正在运行的某个线程/进程切换到下一个。</p>
<p>这些上下文切换有一定的成本——它们消耗了一些时间。在快的时候，可能少于100纳秒，但是根据实现的细节，处理器速度/架构，CPU缓存等，消耗1000纳秒甚至更长的时间也并不罕见。</p>
<p>线程（或者进程）越多，上下文切换就越多。当我们谈论成千上万的线程，并且每一次切换需要数百纳秒时，速度将会变得非常慢。</p>
<p>然而，非阻塞调用本质上是告诉内核“当你有一些新的数据或者这些连接中的任意一个有事件时才调用我”。这些非阻塞调用设计于高效地处理大量的I/O负载，以及减少上下文切换。</p>
<p>到目前为止你还在看这篇文章吗？因为现在来到了有趣的部分：让我们来看下一些流利的语言如何使用这些工具，并就在易用性和性能之间的权衡作出一些结论……以及其他有趣的点评。</p>
<p>请注意，虽然在这篇文章中展示的示例是琐碎的（并且是不完整的，只是显示了相关部分的代码），但数据库访问，外部缓存系统（memcache等全部）和需要I/O的任何东西，都以执行某些背后的I/O操作而结束，这些和展示的示例一样有着同样的影响。同样地，对于I/O被描述为“阻塞”（PHP，Java）这样的情节，HTTP请求与响应的读取与写入本身是阻塞的调用：再一次，更多隐藏在系统中的I/O及其伴随的性能问题需要考虑。</p>
<p>为项目选择编程语言要考虑的因素有很多。当你只考虑性能时，要考虑的因素甚至有更多。但是，如果你关注的是程序主要受限于I/O，如果I/O性能对于你的项目至关重要，那这些都是你需要了解的。“保持简单”的方法：PHP。</p>
<p>回到90年代的时候，很多人穿着匡威鞋，用Perl写着CGI脚本。随后出现了PHP，很多人喜欢使用它，它使得制作动态网页更为容易。</p>
<p>PHP使用的模型相当简单。虽然有一些变化，但基本上PHP服务器看起来像：</p>
<p>HTTP请求来自用户的浏览器，并且访问了你的Apache网站服务器。Apache为每个请求创建一个单独的进程，通过一些优化来重用它们，以便最大程度地减少其需要执行的次数（创建进程相对来说较慢）。Apache调用PHP并告诉它在磁盘上运行相应的.php文件。PHP代码执行并做一些阻塞的I/O调用。若在PHP中调用了file_get_contents()，那在背后它会触发read()系统调用并等待结果返回。</p>
<p>当然，实际的代码只是简单地嵌在你的页面中，并且操作是阻塞的：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-comment">// 阻塞的文件I/O</span><br><span class="hljs-variable">$file_data</span> = file_get_contents(<span class="hljs-string">&#x27;/path/to/file.dat&#x27;</span>);<br><br><span class="hljs-comment">// 阻塞的网络I/O</span><br><span class="hljs-variable">$curl</span> = curl_init(<span class="hljs-string">&#x27;http://example.com/example-microservice&#x27;</span>);<br><span class="hljs-variable">$result</span> = curl_exec(<span class="hljs-variable">$curl</span>);<br><br><span class="hljs-comment">// 更多阻塞的网络I/O</span><br><span class="hljs-variable">$result</span> = <span class="hljs-variable">$db</span>-&gt;query(<span class="hljs-string">&#x27;SELECT id, data FROM examples ORDER BY id DESC limit 100&#x27;</span>);<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<p>关于它如何与系统集成，就像这样：</p>
<p><img  src="/images/0d78356a18a040600cad68d52b7ae.jpg"  ><span class="image-caption">d</span></p>
<p>相当简单：一个请求，一个进程。I/O是阻塞的。优点是什么呢？简单，可行。那缺点是什么呢？同时与20,000个客户端连接，你的服务器就挂了。由于内核提供的用于处理大容量I/O（epoll等）的工具没有被使用，所以这种方法不能很好地扩展。更糟糕的是，为每个请求运行一个单独的过程往往会使用大量的系统资源，尤其是内存，这通常是在这样的场景中遇到的第一件事情。</p>
<p>注意：Ruby使用的方法与PHP非常相似，在广泛而普遍的方式下，我们可以将其视为是相同的。</p>
<h2 id="多线程的方式：Java"><a href="#多线程的方式：Java" class="headerlink" title="多线程的方式：Java"></a>多线程的方式：Java</h2><p>所以就在你买了你的第一个域名的时候，Java来了，并且在一个句子之后随便说一句“dot com”是很酷的。而Java具有语言内置的多线程（特别是在创建时），这一点非常棒。</p>
<p>大多数Java网站服务器通过为每个进来的请求启动一个新的执行线程，然后在该线程中最终调用作为应用程序开发人员的你所编写的函数。</p>
<p>在Java的Servlet中执行I/O操作，往往看起来像是这样：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request,  </span></span><br><span class="hljs-params"><span class="hljs-function">    HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException</span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">// 阻塞的文件I/O</span><br>    InputStream fileIs = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;/path/to/file&quot;</span>);<br><br>    <span class="hljs-comment">// 阻塞的网络I/O</span><br>    URLConnection urlConnection = (<span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;http://example.com/example-microservice&quot;</span>)).openConnection();<br>    InputStream netIs = urlConnection.getInputStream();<br><br>    <span class="hljs-comment">// 更多阻塞的网络I/O</span><br>    out.println(<span class="hljs-string">&quot;...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于我们上面的doGet方法对应于一个请求并且在自己的线程中运行，而不是每次请求都对应需要有自己专属内存的单独进程，所以我们会有一个单独的线程。这样会有一些不错的优点，例如可以在线程之间共享状态、共享缓存的数据等，因为它们可以相互访问各自的内存，但是它如何与调度进行交互的影响，仍然与前面PHP例子中所做的内容几乎一模一样。每个请求都会产生一个新的线程，而在这个线程中的各种I/O操作会一直阻塞，直到这个请求被完全处理为止。为了最小化创建和销毁它们的成本，线程会被汇集在一起，但是依然，有成千上万个连接就意味着成千上万个线程，这对于调度器是不利的。</p>
<p>一个重要的里程碑是，在Java 1.4 版本（和再次显著升级的1.7 版本）中，获得了执行非阻塞I/O调用的能力。大多数应用程序，网站和其他程序，并没有使用它，但至少它是可获得的。一些Java网站服务器尝试以各种方式利用这一点; 然而，绝大多数已经部署的Java应用程序仍然如上所述那样工作。</p>
<p><img  src="/images/fb1694b52ffd8ea112ec2fb5570c0.jpg"  ><span class="image-caption">e</span></p>
<p>Java让我们更进了一步，当然对于I/O也有一些很好的“开箱即用”的功能，但它仍然没有真正解决问题：当你有一个严重I/O绑定的应用程序正在被数千个阻塞线程狂拽着快要坠落至地面时怎么办。</p>
<h2 id="作为一等公民的非阻塞I-O：Node"><a href="#作为一等公民的非阻塞I-O：Node" class="headerlink" title="作为一等公民的非阻塞I/O：Node"></a>作为一等公民的非阻塞I/O：Node</h2><p>当谈到更好的I/O时，Node.js无疑是新宠。任何曾经对Node有过最简单了解的人都被告知它是“非阻塞”的，并且它能有效地处理I/O。在一般意义上，这是正确的。但魔鬼藏在细节中，当谈及性能时这个巫术的实现方式至关重要。</p>
<p>本质上，Node实现的范式不是基本上说“在这里编写代码来处理请求”，而是转变成“在这里写代码开始处理请求”。每次你都需要做一些涉及I/O的事情，发出请求或者提供一个当完成时Node会调用的回调函数。</p>
<p>在求中进行I/O操作的典型Node代码，如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">http.create<span class="hljs-constructor">Server(<span class="hljs-params">function</span>(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>)</span> &#123;  <br>    fs.read<span class="hljs-constructor">File(&#x27;<span class="hljs-operator">/</span><span class="hljs-params">path</span><span class="hljs-operator">/</span><span class="hljs-params">to</span><span class="hljs-operator">/</span><span class="hljs-params">file</span>&#x27;, &#x27;<span class="hljs-params">utf8</span>&#x27;, <span class="hljs-params">function</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data</span>)</span> &#123;<br>        response.<span class="hljs-keyword">end</span>(data);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>可以看到，这里有两个回调函数。第一个会在请求开始时被调用，而第二个会在文件数据可用时被调用。</p>
<p>这样做的基本上给了Node一个在这些回调函数之间有效地处理I/O的机会。一个更加相关的场景是在Node中进行数据库调用，但我不想再列出这个烦人的例子，因为它是完全一样的原则：启动数据库调用，并提供一个回调函数给Node，它使用非阻塞调用单独执行I/O操作，然后在你所要求的数据可用时调用回调函数。这种I/O调用队列，让Node来处理，然后获取回调函数的机制称为“事件循环”。它工作得非常好。</p>
<p><img  src="/images/9f1e8acd49501f676dffef7f3c642.jpg"  ><span class="image-caption">f</span></p>
<p>然而，这个模型中有一道关卡。在幕后，究其原因，更多是如何实现JavaScript V8 引擎（Chrome的JS引擎，用于Node）1，而不是其他任何事情。你所编写的JS代码全部都运行在一个线程中。思考一下。这意味着当使用有效的非阻塞技术执行I/O时，正在进行CPU绑定操作的JS可以在运行在单线程中，每个代码块阻塞下一个。 一个常见的例子是循环数据库记录，在输出到客户端前以某种方式处理它们。以下是一个例子，演示了它如何工作：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> handler = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(request, response)</span> </span>&#123;<br><br>    connection.query(<span class="hljs-string">&#x27;SELECT ...&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err, rows)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (err) &#123; <span class="hljs-keyword">throw</span> err &#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; rows.length; i++) &#123;<br>            <span class="hljs-comment">// 对每一行纪录进行处理</span><br>        &#125;<br><br>        response.end(...); <span class="hljs-comment">// 输出结果</span><br><br>    &#125;)<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>虽然Node确实可以有效地处理I/O，但上面的例子中的for循环使用的是在你主线程中的CPU周期。这意味着，如果你有10,000个连接，该循环有可能会让你整个应用程序慢如蜗牛，具体取决于每次循环需要多长时间。每个请求必须分享在主线程中的一段时间，一次一个。</p>
<p>这个整体概念的前提是I/O操作是最慢的部分，因此最重要是有效地处理这些操作，即使意味着串行进行其他处理。这在某些情况下是正确的，但不是全都正确。</p>
<p>另一点是，虽然这只是一个意见，但是写一堆嵌套的回调可能会令人相当讨厌，有些人认为它使得代码明显无章可循。在Node代码的深处，看到嵌套四层、嵌套五层、甚至更多层级的嵌套并不罕见。</p>
<p>我们再次回到了权衡。如果你主要的性能问题在于I/O，那么Node模型能很好地工作。然而，它的阿喀琉斯之踵（译者注：来自希腊神话，表示致命的弱点）是如果不小心的话，你可能会在某个函数里处理HTTP请求并放置CPU密集型代码，最后使得每个连接慢得如蜗牛。</p>
<h2 id="真正的非阻塞：Go"><a href="#真正的非阻塞：Go" class="headerlink" title="真正的非阻塞：Go"></a>真正的非阻塞：Go</h2><p>在进入Go这一章节之前，我应该披露我是一名Go粉丝。我已经在许多项目中使用Go，是其生产力优势的公开支持者，并且在使用时我在工作中看到了他们。</p>
<p>也就是说，我们来看看它是如何处理I/O的。Go语言的一个关键特性是它包含自己的调度器。并不是每个线程的执行对应于一个单一的OS线程，Go采用的是“goroutines”这一概念。Go运行时可以将一个goroutine分配给一个OS线程并使其执行，或者把它挂起而不与OS线程关联，这取决于goroutine做的是什么。来自Go的HTTP服务器的每个请求都在单独的Goroutine中处理。</p>
<p>此调度器工作的示意图，如下所示：</p>
<p><img  src="/images/c99ced01713937ff76afc9b56416c.jpg"  ><span class="image-caption">g</span></p>
<p>这是通过在Go运行时的各个点来实现的，通过将请求写入/读取/连接/等实现I/O调用，让当前的goroutine进入睡眠状态，当可采取进一步行动时用信息把goroutine重新唤醒。</p>
<p>实际上，除了回调机制内置到I/O调用的实现中并自动与调度器交互外，Go运行时做的事情与Node做的事情并没有太多不同。它也不受必须把所有的处理程序代码都运行在同一个线程中这一限制，Go将会根据其调度器的逻辑自动将Goroutine映射到其认为合适的OS线程上。最后代码类似这样：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br><br>    <span class="hljs-regexp">//</span> 这里底层的网络调用是非阻塞的<br>    rows, err := db.Query(<span class="hljs-string">&quot;SELECT ...&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> _, row := range rows &#123;<br>        <span class="hljs-regexp">//</span> 处理rows<br>        <span class="hljs-regexp">//</span> 每个请求在它自己的goroutine中<br>    &#125;<br><br>    w.Write(...) <span class="hljs-regexp">//</span> 输出响应结果，也是非阻塞的<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>正如你在上面见到的，我们的基本代码结构像是更简单的方式，并且在背后实现了非阻塞I/O。</p>
<p>在大多数情况下，这最终是“两个世界中最好的”。非阻塞I/O用于全部重要的事情，但是你的代码看起来像是阻塞，因此往往更容易理解和维护。Go调度器和OS调度器之间的交互处理了剩下的部分。这不是完整的魔法，如果你建立的是一个大型的系统，那么花更多的时间去理解它工作原理的更多细节是值得的; 但与此同时，“开箱即用”的环境可以很好地工作和很好地进行扩展。</p>
<p>Go可能有它的缺点，但一般来说，它处理I/O的方式不在其中。</p>
<h2 id="谎言，诅咒的谎言和基准"><a href="#谎言，诅咒的谎言和基准" class="headerlink" title="谎言，诅咒的谎言和基准"></a>谎言，诅咒的谎言和基准</h2><p>对这些各种模式的上下文切换进行准确的定时是很困难的。也可以说这对你来没有太大作用。所以取而代之，我会给出一些比较这些服务器环境的HTTP服务器性能的基准。请记住，整个端对端的HTTP请求/响应路径的性能与很多因素有关，而这里我放在一起所提供的数据只是一些样本，以便可以进行基本的比较。</p>
<p>对于这些环境中的每一个，我编写了适当的代码以随机字节读取一个64k大小的文件，运行一个SHA-256哈希N次（N在URL的查询字符串中指定，例如…/test.php?n=100），并以十六进制形式打印生成的散列。我选择了这个示例，是因为使用一些一致的I/O和一个受控的方式增加CPU使用率来运行相同的基准测试是一个非常简单的方式。</p>
<p>关于环境使用，更多细节请参考这些基准要点。</p>
<p>首先，来看一些低并发的例子。运行2000次迭代，并发300个请求，并且每次请求只做一次散列（N = 1），可以得到：</p>
<p><img  src="/images/a90935e5892036d8e30b4950ed448.jpg"  ><span class="image-caption">h</span></p>
<blockquote>
<p>时间是在全部并发请求中完成请求的平均毫秒数。越低越好。</p>
</blockquote>
<p>很难从一个图表就得出结论，但对于我来说，似乎与连接和计算量这些方面有关，我们看到时间更多地与语言本身的一般执行有关，因此更多在于I/O。请注意，被认为是“脚本语言”（输入随意，动态解释）的语言执行速度最慢。</p>
<p>但是如果将N增加到1000，仍然并发300个请求，会发生什么呢 —— 相同的负载，但是hash迭代是之前的100倍（显着增加了CPU负载）：</p>
<p><img  src="/images/8d736ed165a362c8ad101a9486fe5.jpg"  ><span class="image-caption">h</span></p>
<blockquote>
<p>时间是在全部并发请求中完成请求的平均毫秒数。越低越好。</p>
</blockquote>
<p>忽然之间，Node的性能显着下降了，因为每个请求中的CPU密集型操作都相互阻塞了。有趣的是，在这个测试中，PHP的性能要好得多（相对于其他的语言），并且打败了Java。（值得注意的是，在PHP中，SHA-256实现是用C编写的，执行路径在这个循环中花费更多的时间，因为这次我们进行了1000次哈希迭代）。</p>
<p>现在让我们尝试5000个并发连接（并且N = 1）—— 或者接近于此。不幸的是，对于这些环境的大多数，失败率并不明显。对于这个图表，我们会关注每秒的请求总数。越高越好：</p>
<p><img  src="/images/f9a22d54c1d30738d7cd3fe41e415.jpg"  ><span class="image-caption">h</span></p>
<blockquote>
<p>每秒的请求总数。越高越好。</p>
</blockquote>
<p>这张照片看起来截然不同。这是一个猜测，但是看起来像是对于高连接量，每次连接的开销与产生新进程有关，而与PHP + Apache相关联的额外内存似乎成为主要的因素并制约了PHP的性能。显然，Go是这里的冠军，其次是Java和Node，最后是PHP。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综上所述，很显然，随着语言的演进，处理大量I/O的大型应用程序的解决方案也随之不断演进。</p>
<p>为了公平起见，暂且抛开本文的描述，PHP和Java确实有可用于Web应用程序的非阻塞I/O的实现。 但是这些方法并不像上述方法那么常见，并且需要考虑使用这种方法来维护服务器的伴随的操作开销。更不用说你的代码必须以与这些环境相适应的方式进行结构化; “正常”的PHP或Java Web应用程序通常不会在这样的环境中进行重大改动。</p>
<p>作为比较，如果只考虑影响性能和易用性的几个重要因素，可以得到：</p>
<table>
<thead>
<tr>
<th>语言</th>
<th align="center">线程或进程</th>
<th align="right">非阻塞I/O</th>
<th align="right">易用性</th>
</tr>
</thead>
<tbody><tr>
<td>PHP</td>
<td align="center">进程</td>
<td align="right">否</td>
<td align="right"></td>
</tr>
<tr>
<td>Java</td>
<td align="center">线程</td>
<td align="right">可用</td>
<td align="right">需要回调</td>
</tr>
<tr>
<td>Node.js</td>
<td align="center">线程</td>
<td align="right">是</td>
<td align="right">需要回调</td>
</tr>
<tr>
<td>Go</td>
<td align="center">线程（Goroutine）</td>
<td align="right">是</td>
<td align="right">不需要回调</td>
</tr>
</tbody></table>
<p>线程通常要比进程有更高的内存效率，因为它们共享相同的内存空间，而进程则没有。结合与非阻塞I/O相关的因素，当我们向下移动列表到一般的启动时，因为它与改善I/O有关，可以看到至少与上面考虑的因素一样。如果我不得不在上面的比赛中选出一个冠军，那肯定会是Go。</p>
<p>即便这样，在实践中，选择构建应用程序的环境与你的团队对于所述环境的熟悉程度以及可以实现的总体生产力密切相关。因此，每个团队只是一味地扎进去并开始用Node或Go开发Web应用程序和服务可能没有意义。事实上，寻找开发人员或内部团队的熟悉度通常被认为是不使用不同的语言和/或不同的环境的主要原因。也就是说，过去的十五年来，时代已经发生了巨大的变化。</p>
<p>希望以上内容可以帮助你更清楚地了解幕后所发生的事件，并就如何处理应用程序现实世界中的可扩展性为你提供的一些想法。快乐输入，快乐输出！</p>
<hr>
<p>本翻译版权归作者dogstar所有。<br>本网站采用CC BY-NC-SA 3.0许可协议，转载请注明艾翻译(itran.cc)。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Java</tag>
        <tag>Node.js</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>永远年轻，永远热泪盈眶。</title>
    <url>/2021/06/08/%E5%8D%9A%E5%AE%A2%E5%8F%88%E4%BB%8Esolo%E6%90%AC%E8%BF%81%E5%9B%9Ehexo/</url>
    <content><![CDATA[<p>几经周折，距上次写博客又快两年了，买了服务器和域名，没想到一忙下又过期了，还是迁移回免费的gitpage省事,今天正好还是2021高考的第二天，未来的你永远都会记得紧张兴奋勇敢的今天，永远年轻，永远热泪盈眶。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>毕业季</tag>
      </tags>
  </entry>
</search>
